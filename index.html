<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Escena 3D - Como la Imagen</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #mensajePrincipal { 
            position: absolute; 
            top: 20px; 
            left: 50%; 
            transform: translateX(-50%); 
            color: #fff; 
            font-family: Arial; 
            font-size: 18px; 
            padding: 8px 16px; 
            border-radius: 20px; 
            background: rgba(0,0,0,0.7); 
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="mensajePrincipal">Te Amo Muchote Mis Ojitos Brillantes üíõ</div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // 1. Configuraci√≥n b√°sica
        const escena = new THREE.Scene();
        escena.background = new THREE.Color(0x2b0b42); // Morado oscuro del fondo

        const camara = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camara.position.set(0, 5, 15);
        camara.lookAt(0, 0, 0);

        const renderizador = new THREE.WebGLRenderer({ antialias: true });
        renderizador.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderizador.domElement);

        // 2. Estrella del fondo
        const crearEstrellasFondo = () => {
            const geometria = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 500; i++) {
                vertices.push(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    -Math.random() * 50
                );
            }
            geometria.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
            const estrellas = new THREE.Points(geometria, material);
            escena.add(estrellas);
        };
        crearEstrellasFondo();

        // 3. Superficie iluminada
        const crearSuperficie = () => {
            const geometria = new THREE.PlaneGeometry(50, 50);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x5a3b72, 
                transparent: true, 
                opacity: 0.8 
            });
            const superficie = new THREE.Mesh(geometria, material);
            superficie.rotation.x = -Math.PI / 2;
            superficie.position.y = -2;
            escena.add(superficie);

            // Frases y puntos en la superficie
            const frases = [
                "Me Encantas", "Mi Todo", "Mi Infinito", "Hermoso ‚ù§Ô∏è", 
                "Mi Cielo", "Mi Beb√©", "Mi cielo", "Jamasolo", 
                "Mi Canci√≥n Favorita ‚ú®", "Te Amo ‚ù§Ô∏è", "mi vida", "Unica", 
                "Mi Amor", "Mi Rei ‚ú®"
            ];
            const grupoElementos = new THREE.Group();
            escena.add(grupoElementos);

            // Puntos peque√±os
            for (let i = 0; i < 800; i++) {
                const geoPunto = new THREE.SphereGeometry(0.08, 4, 4);
                const matPunto = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const punto = new THREE.Mesh(geoPunto, matPunto);
                punto.position.set(
                    (Math.random() - 0.5) * 40,
                    -2,
                    (Math.random() - 0.5) * 40
                );
                grupoElementos.add(punto);
            }

            // Frases como cajas brillantes
            for (let frase of frases) {
                const geoFrase = new THREE.BoxGeometry(
                    frase.length * 0.3, 
                    0.5, 
                    0.1
                );
                const matFrase = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff, 
                    emissive: 0xffffff,
                    emissiveIntensity: 0.5
                });
                const elementoFrase = new THREE.Mesh(geoFrase, matFrase);
                elementoFrase.position.set(
                    (Math.random() - 0.5) * 35,
                    -1.95,
                    (Math.random() - 0.5) * 35
                );
                elementoFrase.userData.texto = frase; // Para referencia
                grupoElementos.add(elementoFrase);
            }
        };
        crearSuperficie();

        // 4. Esfera central
        const crearEsferaCentral = () => {
            const geometria = new THREE.SphereGeometry(2, 32, 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x1a0a2b, 
                emissive: 0x2b0b42,
                emissiveIntensity: 0.3
            });
            const esfera = new THREE.Mesh(geometria, material);
            esfera.position.y = -0.5;
            escena.add(esfera);

            // Part√≠culas alrededor de la esfera
            const geoParticulas = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 100; i++) {
                const radio = 2 + Math.random() * 1;
                const angulo = Math.random() * Math.PI * 2;
                vertices.push(
                    Math.cos(angulo) * radio,
                    -0.5 + (Math.random() - 0.5) * 2,
                    Math.sin(angulo) * radio
                );
            }
            geoParticulas.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const matParticulas = new THREE.PointsMaterial({ color: 0xffffff, size: 0.15 });
            const particulas = new THREE.Points(geoParticulas, matParticulas);
            escena.add(particulas);
        };
        crearEsferaCentral();

        // 5. Animaci√≥n y ajuste de ventana
        function animar() {
            requestAnimationFrame(animar);
            renderizador.render(escena, camara);
        }
        animar();

        window.addEventListener('resize', () => {
            camara.aspect = window.innerWidth / window.innerHeight;
            camara.updateProjectionMatrix();
            renderizador.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
