<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Escena 3D Masculina</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #121212; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/geometries/TextGeometry.js"></script>

<script>
  // Escena y cámara
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 15, 40);

  // Renderizador
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Control de cámara
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;

  // Luz ambiental y puntual
  const ambientLight = new THREE.AmbientLight(0x404040, 2);
  scene.add(ambientLight);
  const pointLight = new THREE.PointLight(0x5588ff, 2);
  pointLight.position.set(0, 20, 20);
  scene.add(pointLight);

  // Esfera central (como un planeta oscuro)
  const sphereGeometry = new THREE.SphereGeometry(5, 64, 64);
  const sphereMaterial = new THREE.MeshStandardMaterial({
    color: 0x1a1a1a,
    metalness: 0.8,
    roughness: 0.2,
    emissive: 0x0a0a0a
  });
  const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
  scene.add(sphere);

  // Anillo alrededor (como un anillo de Saturno)
  const ringGeometry = new THREE.RingGeometry(6, 7, 64);
  const ringMaterial = new THREE.MeshBasicMaterial({
    color: 0x3366ff,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.6
  });
  const ring = new THREE.Mesh(ringGeometry, ringMaterial);
  ring.rotation.x = Math.PI / 2;
  scene.add(ring);

  // Partículas (disco de puntos alrededor)
  const particleCount = 500;
  const positions = new Float32Array(particleCount * 3);
  for(let i=0; i<particleCount; i++){
    const angle = Math.random() * 2 * Math.PI;
    const radius = 7 + Math.random() * 5;
    const height = (Math.random() - 0.5) * 0.5; // Disco plano, un poco de dispersión vertical
    positions[i*3] = Math.cos(angle) * radius;
    positions[i*3 + 1] = height;
    positions[i*3 + 2] = Math.sin(angle) * radius;
  }
  const particleGeometry = new THREE.BufferGeometry();
  particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const particleMaterial = new THREE.PointsMaterial({
    color: 0x5599ff,
    size: 0.1,
    sizeAttenuation: true,
    transparent: true,
    opacity: 0.8
  });
  const particles = new THREE.Points(particleGeometry, particleMaterial);
  scene.add(particles);

  // Texto flotante con mensajes masculinos
  const loader = new THREE.FontLoader();
  loader.load('https://cdn.jsdelivr.net/npm/three@0.150.1/examples/fonts/helvetiker_regular.typeface.json', function(font){

    const mensajes = [
      "Eres Mi Fuerza",
      "Mi Compañero",
      "Mi Rey",
      "Valiente",
      "Mi Héroe",
      "Inigualable",
      "Siempre Contigo",
      "Mi Confianza",
      "Amor Firme",
      "Mi Todo"
    ];

    const textMeshes = [];

    mensajes.forEach((texto, i) => {
      const textGeometry = new THREE.TextGeometry(texto, {
        font: font,
        size: 0.8,
        height: 0.1,
        curveSegments: 12,
        bevelEnabled: false
      });
      const textMaterial = new THREE.MeshBasicMaterial({color: 0x3399ff});
      const textMesh = new THREE.Mesh(textGeometry, textMaterial);

      // Posicionar texto en un círculo alrededor de la esfera
      const angle = (i / mensajes.length) * 2 * Math.PI;
      const radius = 12;
      textMesh.position.set(
        Math.cos(angle) * radius - texto.length * 0.2,
        2 + (Math.sin(angle * 3) * 1.5), // un poco de movimiento vertical
        Math.sin(angle) * radius
      );
      textMesh.lookAt(camera.position);
      scene.add(textMesh);
      textMeshes.push(textMesh);
    });

    // Animación
    function animate(){
      requestAnimationFrame(animate);
      controls.update();

      // Rotar anillo y partículas lentamente
      ring.rotation.z += 0.002;
      particles.rotation.z += 0.0015;

      // Hacer que el texto mire siempre a la cámara
      textMeshes.forEach(mesh => {
        mesh.lookAt(camera.position);
      });

      renderer.render(scene, camera);
    }
    animate();
  });

  // Ajustar tamaño al cambiar ventana
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
